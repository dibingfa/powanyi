# 你管这破玩意叫指针

内存，通常被严谨地画成下面这个样子，一个下方是低地址上方是高地址的格子楼。

![image-20230107133227861](zhizhen/image-20230107133227861.png)

但我今天换种画法，像下面这个样子。

![image-20230107133450358](zhizhen/image-20230107133450358.png)

每个格子代表内存中的 1 个字节（8 位），格子上的数字就代表内存地址，我也直接用 10 进制来表示了。目前内存是完全空的，格子里没有任何内容。

试想一下，如果你忘掉所有的编程语言和编程规范，你会如何描述你对这些内存格子的操作呢？



## 类型系统

很简单，往格子 3 处放个数字 29，往格子 6 处放个数字 38，就这么描述即可。

![image-20230107134529173](zhizhen/image-20230107134529173.png)

但是这样说话太麻烦了，什么往格子 3 处放个数字 29 的，废话太多。

那我们就定个指令，使用 mov $x, (y) 表示把数字 x 放入格子 y，如下：

```
mov $29, (3)
mov $38, (6)
```

这就表示刚刚说的：

```
把数字 29 放入内存格子 3
把数字 38 放入内存格子 6
```

是不是太简单了？别急，好戏马上开始！

如果要把数字 999 放入内存格子 8，该怎么办呢？

由于 1 个格子只有 8 位，因此只能表示 256 个数字，要么是有符号的 -128 ~ 127，要么是无符号的 0 ~255，显然数字 999 无法放在一个格子内，只能占用两个格子了。

那也好办，就这么说，把数字 999 放入格子 8，连续占用两个格子。

![image-20230107141554790](zhizhen/image-20230107141554790.png)

但这样，我们刚刚的 mov 指令就得改改了，不但要表示"存放"这个含义，还得表示占用了多少个格子。

我们用 movb 表示只占 1 个字节，用 movw 表示占用 2 个字节。那么，刚刚的三个数字，就分别可以这样用指令来表示了：

```
movb $29, (3)
movb $38, (6)
movw $999, (8)
```

含义就是：

```
把数字 29 放入内存格子 3，占 1 个字节
把数字 38 放入内存格子 6，占 1 个字节
把数字 999 放入内存格子 8，占 2 个字节
```

OK，既然有了 1 字节和 2 字节的的指令，不妨再设计下，用 movl 表示 4 字节，movq 表示 8 字节 ...

```
movb 占用 1 字节
movw 占用 2 字节
movl 占用 4 字节
movq 占用 8 字节
```

不知不觉，类型系统就被你悄悄设计出来了！当然，虽然这只是个半成品。



## 变量

你不断地往不同格子里放数据。

比如我把我的年龄放在 11 号格子（占 1 字节），把我的月薪放在 14 号格子（占 4 字节）。

![image-20230107141838353](zhizhen/image-20230107141838353.png)

现在我们的内存已经非常混乱了，你根本记不住原来的 3 号格子放的数据表示什么，11 号格子又表示什么，只能通过看数字知道 14 号格子里放的确实是我的月薪。这该怎么办呢？

增加一层抽象嘛！我们给这些放了我们数据的格子，都贴上个标签，就可以不用再记那些无意义的格子编号了。

![image-20230107142514914](zhizhen/image-20230107142514914.png)

这样以来，其实我们也不再关心，这些标签到底在哪个格子里，只要给我找到格子把我的数据放进去就可以了。

```
movb $29, a
movb $38, b
movw $999, c
movb $18, age
movl $2147483647, salary
```

当然，我还需要再通过这个标签，把我刚刚放进去的数据找出来。

这很简单，但存在一个问题，放进去的时候，我们可以通过 movb，movw，movl 等知道占用多少个格子。而取出来的时候，标签上可没有写这个数据占用了多少个格子，这是有问题的。

因此，在定义这个标签时，不能光取个名字，还需要有个信息就是，这个标签对应的数据，占了多少个格子。

我们就效仿刚刚的存放操作，也规定一系列单词，来修饰这些标签，表示占用了多少个格子。

char 表示 1 个字节，short 表示 2 个字节，int 表示 4 个字节，long 表示 8 个字节 ...

![image-20230107163433771](zhizhen/image-20230107163433771.png)

于是乎刚刚的 5 个数据，就可以表示为如下指令：

```c
char a = 29;
char b = 38;
short c = 999;
char age = 18;
int salary = 2147483647;
```

行了，我也别藏着掖着了，相信大家也知道，这里就是 C 语言的写法，而刚刚那堆 mov 是汇编语言的写法。

这些 char a，char b，int salary 等，就是变量！记住，变量不但要有名字，还得有类型！



## 变量定义与赋值

其实，刚刚写法，是把变量的定义与赋值操作写在一行了。

比如有如下语句：

```c
int a = 1;
```

实际上是分成两步的：

```c
// 变量的定义
int a;
// 变量的赋值
a = 1;
```

其中变量的定义是为了程序员后面去用它赋值，这部分不是给 CPU 看的。

![image-20230107164618790](zhizhen/image-20230107164618790.png)

而变量的赋值才是真正在内存中把数据放进去，这部分才真正涉及 CPU 具体指令的执行。

![image-20230107164714760](zhizhen/image-20230107164714760.png)



## 指针

现在，让我们把内存清空，回到一开始的那一片净土上。

![image-20230107133450358](zhizhen/image-20230107133450358.png)

现在，我来搞点花样。我将我的密码（1234）存储在一个 short a 中，假设这个变量 a 被放在了 6 号格子处。

![image-20230107171500628](zhizhen/image-20230107171500628.png)

同时，我将这个变量 a 的地址，也就是 6 这个数字，存储在另一个变量 int p 中，假设这个变量 p 被放在了 1 号格子处。

![image-20230107171711203](zhizhen/image-20230107171711203.png)

这样，我寻找我密码的方式，就是先通过 p 所在的内存地址找到里面存的值，也就是 a 的内存地址 6，再通过 a 的内存地址找到里面存的值，也就是我要找的密码 1234。

我们可以用下面的代码来表示刚刚的存放逻辑。

```c
short a = 1234;
// 假设我们已经知道上面的变量 a 被放在了 6 号格子处
int p = 6;
```

这里的 p 和 a 都是变量，只不过，p 这个变量有点特殊，它里面存放的值是一个内存地址，我们把 p 这个变量形象地成为指针变量，简称指针。

不过，这样有几个问题，我一个个来说。

### 1. 取地址

首先，我们在编码阶段，无法知道也无需知道变量 a 会存放在哪里，不然就失去了标签的含义，又回到了需要关心具体的内存地址（也就是格子编号）的时代了。

所以，我们应该有个方法，来在编码阶段表示变量 a 的地址的含义，姑且就叫做 &a 吧。

那么我们的代码，就可以优化为：

```c
short a = 1234;
// 假设 a 的地址是 6，那么下面的 p 就等于 6
int p = &a;
```

用图来表示就是：

![image-20230107194058432](zhizhen/image-20230107194058432.png)

### 2. 指针变量本身的大小

视角放到这个变量 p 身上，虽然本质上这个变量 p 里面存放的就是一个数值，假设是 6，但是它却表示了一个内存地址的值。如果让程序员随便规定这个变量 p 的数据类型（也就是占多少个字节），那显然容易出问题。

比如内存地址是 999，那么我用一个 char 类型的变量 p 来存放它，就会有问题。

我们在编码阶段是无法确定一个内存地址的值是多少，那么用什么类型的变量来存放它，也是无法判断的。

所以，最稳妥的办法就是，用一个完全能容纳所有内存地址范围的变量类型来存放指针变量，我们姑且认为我们是在一个 32 位的系统上，那么用一个 4 字节大小的变量来存放，就可以了。（当然，实际上这取决于你的编译器的位数）

现在，我们的指针变量所占用的内存大小，就是 4 个字节，也就是 4 个格子，我们就可以把 p 前面的数据类型去掉了。

```c
short a = 1234;
p = &a;
```

### 3. 指针变量的类型

刚刚我们解决了指针变量本身所占用的内存大小，但是还有一个问题没有解决，就是指针变量里存放的内存地址处的变量的大小。

也就是说，上面的指针变量 p 里虽然存放了变量 a 的内存地址 6，但是指针变量 p 却没有任何信息，来说明内存地址 6 处的变量，它的大小是多少。

假如，我们认为内存地址 6 处的变量是个 char 类型，也就是只占用了一个字节，那么显然，会取出一个不符合预期的值。

![image-20230107195426509](zhizhen/image-20230107195426509.png)

当然，如果认为 6 处的变量是个 int 类型，占 4 个字节，虽然数值上可能没有问题，但从某种程度上讲也是不太符合预期的。

![image-20230107195620689](zhizhen/image-20230107195620689.png)

所以，必须得完全按照变量本身的类型，也就是 short 类型来读取此内存地址处的值，才是正确的。

那我们应该如何表示这个信息呢？即如何表示，变量 p 是一个指针，且这个指针里面存放的内存地址处的变量的类型是 short。

很好办，直接说答案吧。

```c
short a = 1234;
short * p = &a;
```

p 前面的 * 表示变量 p 是一个指针类型，再前面的 short 表示该指针指向的内存地址处的变量，是个 short 类型的变量。

![image-20230107200434525](zhizhen/image-20230107200434525.png)

注意哦，这个 short 不是指针变量本身的类型，指针变量本身我们前面说过了，就是固定的 4 字节大小。

不过总是这样说太绕口了，今后我们就说，变量 p 是个 short * 类型的指针，就可以了。

用上面的图形象地说就是，右边变量 a 蓝色的填充，表示 a 是个 short 类型，而外面的虚线框框，表示指针 p 按照 short 类型的变量来"解读"内存地址 6 处的数值。

### 4. 



## 参考资料与工具

GNU C Manual：https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html

在线观察 C 语言的汇编代码：https://godbolt.org/

